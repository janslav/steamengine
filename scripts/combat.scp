[function typ_boje]
say(muj typ boje: <tag(combattype)>, <tag(weapflag)<tag(mi_weapflags)>>)

[function temporary_null]
tag(UC,0)
tag(ammoid,0)
tag(SM,0)
tag(OM,0)
tag(speedset,"")
tag(hitspeed,0)

[function zbran_char]
if (finduid(tag(weaponuid)))
 if (tag(weaponuid)==findlayer(tag(weaponuid).typedef.layer))//je to v poradku
  return <tag(weaponuid)>
 endif
endif
tag(weaponuid,0)
if (findlayer(1))
 if (findlayer(1).isweapon)
  tag(weaponuid,<findlayer(1)>)
 endif
endif
if (findlayer(2))
 if (findlayer(2).isweapon)
  tag(weaponuid,<findlayer(2)>)
 endif
endif
return <tag(weaponuid)>

[function f_getatack_nonmystik]
if (zbran_char)
 if (tag(weaponuid).type==t_weapon_sword)
  tag(atskill,40)
  tag(weapflag,dam_physical|dam_sharp|dam_slashing)
 elseif (tag(weaponuid).type==t_weapon_fence)
  tag(atskill,42)
  tag(weapflag,dam_physical|dam_sharp|dam_piercing)
 elseif (tag(weaponuid).type==T_WEAPON_MACE_CROOK)||(tag(weaponuid).type==T_WEAPON_MACE_SMITH)||(tag(weaponuid).type==T_WEAPON_MACE_STAFF)
  tag(atskill,41)
  tag(weapflag,dam_physical|dam_blunt)
 elseif (tag(weaponuid).type==t_weapon_bow_run)||(tag(weaponuid).type==T_WEAPON_XBOW)||(tag(weaponuid).type==T_WEAPON_BOW)
  tag(weapflag,dam_physical|dam_piercing)
  tag(atskill,31)
 else
  tag(weapflag,dam_physical|dam_blunt)
  tag(atskill,43)//wrest
 endif
else//prece sand nemuze pouzivat info ze zbrane, kterou treba uz nema
    //elseif !(tag(weapflag))
 tag(weapflag,dam_physical|dam_blunt)
 tag(atskill,43)//wrest
endif

if (tag(atskill)==43)//wrestling
 arg(base_dam,<nastaveni_weapdam_barehands>)
else
 arg(base_dam,<eval tag(weaponuid).typedef.dam>)
 if (arg(base_dam)<nastaveni_weapdam_barehands)
  arg(base_dam,<nastaveni_weapdam_barehands>)
 endif
endif

arg(tactics_dam,<eval ((arg(base_dam)*(tactics*Skill_Tactics.effect))+500000)/1000000>)
arg(str_dam,<eval ((arg(base_dam)*(str*nastaveni_global_strUC))+50000)/100000>)
arg(anatomy_dam,<eval ((arg(base_dam)*(anatomy*SKILL_ANATOMY.effect))+500000)/1000000>)
arg(armslor_dam,<eval ((arg(base_dam)*(armslore*SKILL_ARMSLORE.effect))+500000)/1000000>)

tag(UC,<eval arg(tactics_dam)+arg(str_dam)+arg(anatomy_dam)+arg(armslor_dam)>)
tag(fizzlechance,1000)
tag(piercing,<?eval nastaveni_weappiercing_<tag(weaponuid).typedef.dispid>?>)
if (tag(atskill)==31)//archery
 if (tag(weaponuid).type==t_weapon_bow_run)
  tag(UC,<eval ((tag(UC)*nastaveni_global_runbowdam)+500)/1000>)
  tag(fizzlechance,<eval ((tag(ability)*nastaveni_global_runbowfizzle)+50000)/100000>)
 endif
 if (findtype(tag(weaponuid).typedef.tdata3))
  tag(ammoid,<findtype(<tag(weaponuid).typedef.tdata3>).baseid>)
  arg(arrowbonus,<nastaveni_arrowdamage_<eval findtype(<tag(weaponuid).typedef.tdata3>).typedef.tdata1>>)
  tag(piercing,<nastaveni_arrowdamage_<eval findtype(<tag(weaponuid).typedef.tdata3>).typedef.tdata2>>)
  tag(fizzlechance,0)
  tag(UC,<eval ((tag(UC)*arg(arrowbonus))+500)/1000>)
 else
  tag(UC,0)
  tag(ammoid,0)
 endif
endif
//oprava podle zniceni zbrane
if (tag(atskill)!=43)
  arg(durkvocient, <eval ((<tag(weaponuid).more1h>-<tag(weaponuid).more1l>)*1000)/<tag(weaponuid).more1h> >)
  tag(UC,<eval tag(UC)-((<eval tag(UC)>*<arg(durkvocient)>)/2000)>)
endif

tag(UC,<eval ((tag(UC)*nastaveni_global_UC)+500)/1000>)//globalni nastaveni

[function f_getatack_mystik]
tag(UC,<eval nastaveni_ability_mystikUC>)
tag(atskill,43)

[function combat_main_mystik]
act.dospellcustom_donesrc(103,<calcspelleffect(103)>,<uid>)
//sebrat manashield a manu eventuelne
if(<tag(manashield)>)
 findid(i_a_mana_shield).remove
 sfx(511) //untrap , konec manashieldu   
 if(<mana> > <eval <int>/2>)
  mana=<eval (<mana>-<eval <int>/2>)>
 else
  mana=0
 endif 
endif   
//
mana=<eval (mana*nastaveni_mystik_manaloss)/1000)>
tag.remove(speedset)
tag(hitspeed,0)
p=<tag(mystik_storepos)>
tag.remove(mystik_storepos)

[function combat_main_nonmystik]
bark(2)
if !(tag(UC))
 f_getatack_nonmystik
elseif (tag(atskill)==01f)
 if !(tag.ammoid)
  f_getatack_nonmystik
 elseif (tag(ammoid)!=findtype(<tag(weaponuid).typedef.tdata3>).baseid)
  f_getatack_nonmystik
 endif
endif
arg(celk_dam,<tag(UC)>)
if (act.isplayer)//pvp
 arg(celk_dam,<eval ((arg(celk_dam)*nastaveni_global_PvPweapattack)+500)/1000>)
elseif (act.npc)//Utok jde na M
 if (<tag(level)> > 200)
  arg(useable_level,200)
 else
  arg(useable_level,<tag(level)>)
 endif
 arg(celk_dam,<eval ((arg(celk_dam)*(nastaveni_global_vMweapattack+(arg(useable_level)*10)))+500)/1000>)
endif

act.damagecust(<arg(celk_dam)>,<hval tag(weapflag)<tag(mi_weapflags)>>,<eval tag(piercing)>)

if (var(ubrano))
 //if !(tag(piercing))
  if !(act.isplayer)    
  elseif (tag(fizzlechance)>{0 999})
  else
   return 0
  endif
  act.stopmagery
//endif
endif

[function combat_main_npc]
if(<tag(hypno_mystik)>) //mystik v tele monstra
 arg(celk_dam,<eval ((<argv(0)>*<nastaveni_global_MUC>)+500)/1000>) //je jedno kterej argument
 //kermel.sysmessage(mystik <name> v tele monstra, celk dam: <celk_dam>, arg: <argv(0)>, modfi: <nastaveni_global_MUC>)
else
 //kermel.sysmessage(utoci normal monstrum)
 arg(celk_dam,<eval ((typedef.dam*nastaveni_global_MUC)+500)/1000>)
endif
if (<act.npc>)//Utok jde na M
 //kermel.sysmessage(utok na npc)
 arg(celk_dam,<eval ((arg(celk_dam)*nastaveni_global_vMweapattack)+500)/1000>)
 //if(<tag(hypno_mystik)>)
 // kermel.sysmessage(mystik utoci na normal monstrum, dam: <celk_dam>)
 //endif 
 act.damagecust(<arg(celk_dam)>,<hval tag(weapflag)<tag(mi_weapflags)>>,<eval tag(piercing)+typedef.tag(piercing)>)
else //utok na playera
 if(<act.tag(hypno_mystik)>) //utoci se na mystikovo monstrum  
  //kermel.sysmessage(utok na mystika v tele monstra)
  arg(celk_dam,<eval ((arg(celk_dam)*nastaveni_global_vMweapattack)+500)/1000>)
  act.damagecust(<arg(celk_dam)>,<hval tag(weapflag)<tag(mi_weapflags)>>,<eval tag(piercing)+typedef.tag(piercing)>)    
 else //hrac
  act.damagecust_MvP(<arg(celk_dam)>,<hval tag(weapflag)<tag(mi_weapflags)>>,<eval tag(piercing)+typedef.tag(piercing)>)
 endif
endif
if (var(ubrano))
  if (poisoning)
    act.events(-e_spelleffect)
    act.poison(<poisoning>)
    act.events(+e_spelleffect)
  endif
  act.stopmagery
endif

[function combat_main]
if(<tag(hypno_mystik)>) //hypnotizujici mystik (v tele monstra) 
 combat_main_npc(<tag(dam)>) //2 argumenty obycejne
else
 combat_main_<tag(combattype)>
endif

[function f_getspeed_]
setallcombatrelated

[function combat_main_]
setallcombatrelated

[function setallcombatrelated]
if (isplayer)
  setplayer
elseif (npc)
  tag(combattype,"npc")
  if !(isevent(e_gethit))
    creaturestart
  endif
endif

[function damagecust]//armorsum
//<argv(0)>	ut. cislo
//<argv(1)>	flag
//<argv(2)>	piercing
arg(lowerac,<eval 1000-argv(2)>)
//kermel.sysmessage(Snizeni piercingem: <arg(lowerac)>)
if (isplayer)
  if (src.isplayer)&&(!<src.tag(hypno_mystik)>)
    arg(obrana,<eval armorsum+(nastaveni_global_armorchange_vP_<profession.name>)>)
    arg(poskozeni,<nastaveni_global_PvPweapdam>)
  else
    arg(obrana,<eval armorsum+(nastaveni_global_armorchange_vM_<profession.name>)>)
    arg(poskozeni,1000)
  endif
  if (arg(obrana)>0)
    arg(obrana,<eval arg(obrana)*nastaveni_global_Parmor>)
  else
    arg(obrana, 0)
  endif
else
 arg(poskozeni,<nastaveni_global_vMweapdam>)
 arg(obrana,<eval armorsum*nastaveni_global_Marmor>)
 //if(<src.tag(hypno_mystik)>)
 // kermel.sysmessage(dostava monstrum od mystika, posk: <poskozeni>, obrana: <obrana>) 
 //endif
endif
if (src.npc)
 arg(poskozeni,<eval(((arg(poskozeni)*nastaveni_global_Mvweapdam)+500)/1000)>)
endif
arg(obrana,<eval ((randfakt(<obrana>,<skill_parrying.effect>)*arg(lowerac))+500)/1000>)
var(ubrano,<eval ((((argv(0)*1000)-arg(obrana))*arg(poskozeni))+500000)/1000000>)
var(damage_flags,<hval(argv(1))>)
//if(<src.tag(hypno_mystik)>)
// kermel.sysmessage(mystikuv utok, posk: <var(ubrano)>) 
//endif
damage_final

[function damagecust_MvP]
//<argv(0)>	ut. cislo 
//<argv(1)>	flag    
//<argv(2)>	piercing

arg(obrana,<eval armorsum*(1000-argv(2))>)//1000x zvetsen rad
arg(utok,<eval argv(0)*nastaveni_global_Mvweapdam>)//1000x zvetsen rad
var(ubrano,<eval ((arg(utok)*(1000-(arg(obrana)/nastaveni_global_MvP_armorfactor)))+500000)/1000000>)
var(ubrano,<eval ((var(ubrano)*{<nastaveni_global_MvP_randomfactor>})+500)/1000>)
var(damage_flags,<hval(argv(1))>)
damage_final
//say("damage: <var(ubrano)> hp")
                              
[function damage_final]      //SRC- UTOCNIK, UID - POSKOZENY
//say <var(ubrano)> pred resistem
var(ubrano,<eval(((handleresists(<var(damage_flags)>)*var(ubrano))+500)/1000)>)
//say <var(ubrano)> hp, handler <handleresists(<var(damage_flags)>)>
//say(<var(ubrano)> hp, flags <var(damage_flags)>)
if (var(damage_flags)==088) //poison
 //src.sysmessage(poison!)
 if (var(ubrano)>0)
  //say(<var(ubrano)> hp, flags <var(damage_flags)>)
  damage_noresponse(<var(ubrano)>,dam_god)
  return 1
 endif
elseif !(var(damage_flags)&dam_bleed) //neni bleed 
  //say(NENI BLEED!)
  damage_armors(<var(ubrano)>) //zde i zpracuje manashield, pripadne
  var(swingedchar,<uid>)
  physicaldodge
  src.trigger(@afterswing)
  trigger(@aftergetswing)
  var(dodged,0)
  //manashield testujeme az po triggerech kvuli lidem s vysavanim atd.
  if(<var(manashield_used)>) //pouzit manashield
   //say(Manashield a neni bleed)
   if(<safe var(koupis)>) //a zbylo nejake dmg ktere mame jeste dostat (manashield vyprsel)
    //kermel.sysmessage(<name>, MS used s mensim dmg)
    var(ubrano,<var(koupis)>) //dostaneme min
    var(koupis,0)    
   else //manashield pouze pouzit a jeste nevyprsel
    //kermel.sysmessage(<name>, MS used bez dmg)
    var(ubrano,0) //nic nebude !
    flag_freeze=0 //kdyby nahodou
    var(manashield_used,0) //zde uz koncime tohle kolo
   endif    
  endif
endif
if(src.npc)
 if(npc) //jen monstrum na monstrum 
  if(ubrano < 1)
   var(ubrano,5)
  endif
 endif
endif
if(!var(ubrano))
 flag_freeze=0 //vzdycky a basta. kdo se s tim ma furt srat  
 if(src.isplayer) 
  if(<src.tag(atskill)>==43)&&(!src.findlayer(1))&&(!src.findlayer(2))&&(!<src.tag(hypno_mystik)>)   
    var(ubrano,1) //kvuli odparovani a mozna taky klerici si nejakej ten exp privydelaj!   
  endif
 endif
endif
if (<var(ubrano)> > 0) //at uz MS pouzit nebo ne.
 if(src.isplayer)    
  if(<src.tag(atskill)>==43)&&(!src.findlayer(1))&&(!src.findlayer(2))&&(!<src.tag(hypno_mystik)>)  //wrestling, beze zbrane      
   var(ubrano,<eval (<src.wrestling>/200+1)>)      
  endif  
 endif
  flag_freeze=0
  if(<tag(manashield)>)
   //say(Mam Manashield na konci)
   if(<safe var(manashield_used)>) //pouzit manashield (nebyl-li bleed, ni poison, viz nahore)
    var(manashield_used,0)
    events(-e_gethit)
    damage(<var(ubrano)>,dam_god,<src>) //ubrano upraveno tim var(koupis) o kousek vyse
    events(+e_gethit)
    return 1
   else
    manashield(<var(ubrano)>,<var(damage_flags)>) //prisel cas na pouziti manashieldu (prvni!)
    if(<var(koupis)>) //zbylo nejake dmg a manashield se tim vycerpal
     var(ubrano,<var(koupis)>) //nic nebude !
     var(manashield_used,0)
     var(koupis,0)
    else //ustal utok, manashield jeste zustava    
     var(ubrano,0)
     var(manashield_used,0)
    endif    
   endif
  endif  
  if (flag_reactive)   
   src.damage(<eval(<var(ubrano)>/4)>,dam_god,<src>)//made in enrico 
  endif
  //if(<src.tag(hypno_mystik)>)
  // kermel.sysmessage(hypnomystik damage <var(ubrano)>)	
  //endif
  events(-e_gethit)
  //na zkousku zmeneno na odecitani zivotu, overit jestli fizzujou kouzla, pokud ne, nasli jsme pricinu  - Dinivan
  damage(<var(ubrano)>,dam_god,<src>)  
  //hits=<eval (<hits>-<var(ubrano)>)>
  events(+e_gethit)
endif
var(je_to_wrestling,"")

[function damage_noresponse]//god damage that just removes hitpoints, raises no triggers, has no source.
if (argv(0))>0)
  flag_freeze=0
  if(<tag(manashield)>)
    manashield(<argv(0)>,<var(damage_flags)>)
    return 1
  endif
  hits=<eval hits-argv(0)>
endif

[function damage_armors]
if(<tag(manashield)>)
  //kermel.say(<name> Manashield v damage armorsech)
  manashield(<argv(0)>,<var(damage_flags)>)
endif
armor_localdam(<bodypart_layers[<eval {1 14 2 6 3 36 4 7 5 7 6 23}>]>)
//14+6+36+7+7+23=93. neco tu chybi :) ale nevadi. nejak to blbne nebo co (Dinivan)

[function armor_localdam]
var(localARsum,0)
arg(i,0)
while (i<argvcount)
  if (<findlayer(<argv(i)>)>)
    if (findlayer(<argv(i)>).typedef.type==t_armor) || (findlayer(<argv(i)>).typedef.type==t_armor_leather) || (findlayer(<argv(i)>).typedef.type==t_clothing)
      var(localARsum,#+<findlayer(<argv(i)>).typedef.armor>)
    endif
  endif
  arg(i,#+1)
endwhile
if (flag_hasshield)
  var(localARsum,#+<eval 2*(<findlayer(2).typedef.armor>)>)
  findlayer(2).damage(<eval ((<var(ubrano)>*<nastaveni_global_armorIdam>)/((<var(localARsum)>*1000)/(2*<findlayer(2).typedef.armor>)))>)
endif
arg(i,0)
while (i<argvcount)
  arg(item,<findlayer(<argv(i)>)>)
  if (<arg(item)>)
    if (<finduid(<arg(item)>)>)
      if (finduid(<arg(item)>).typedef.type==t_armor) || (finduid(<arg(item)>).typedef.type==t_armor_leather) || (finduid(<arg(item)>).typedef.type==t_clothing)
        finduid(<arg(item)>).damage(<eval ((var(ubrano)*nastaveni_global_armorIdam)/((var(localARsum)*1000)/findlayer(<argv(<arg(i)>)>).typedef.armor))>)
      endif
    else
      say("neni AR")
    endif
  endif
  arg(i,#+1)
endwhile

[function f_getspeed_mystik]
arg(sqrtmana,<sqrt_int(<eval mana/2>)>)
arg(speed,<eval arg(sqrtmana)*nastaveni_weapspeed_mystik>)
arg(speed,<eval ((arg(speed)*nastaveni_global_weapspeed)+500)/1000>)
if !(<eval arg(speed)>)
 arg(speed,50)
endif
tag(hitspeed,<eval 0fffff/arg(speed)>)

[function f_getspeed_nonmystik]
arg(sqrtdex,<sqrt_int(<eval DEX>)-2>) //-new
if (zbran_char)
 arg(speed,<eval arg(sqrtdex)*nastaveni_weapspeed_<tag(weaponuid).typedef.dispid>>)
else
 arg(speed,<eval arg(sqrtdex)*nastaveni_weapspeed_barehands>)
endif
arg(speed,<eval ((arg(speed)*nastaveni_global_weapspeed)+500)/1000>)
if !(<eval arg(speed)>)
 arg(speed,50)
endif
tag(hitspeed,<eval 0fffff/arg(speed)>)

[function f_getspeed_npc]
if(tag(npc_speed))
 arg(sqrtdex,<sqrt_int(<eval tag(npc_speed)/2>)>)
else
 arg(sqrtdex,<sqrt_int(<eval MAXSTAM/2>)>)
endif
arg(speed,<eval arg(sqrtdex)*nastaveni_weapspeed_npc>)
arg(speed,<eval ((arg(speed)*nastaveni_global_weapspeed)+500)/1000>)
if !(<eval arg(speed)>)
 arg(speed,50)
endif
tag(hitspeed,<eval 0fffff/arg(speed)>)

[function speedtimer]
if !(tag(speedset))
  if(<tag(hypno_mystik)>)
    f_getspeed_npc  
  endif
  if !(tag(hitspeed))    
    f_getspeed_<tag(combattype)>
  endif
  newitemsafe(i_speedtimer)
  lastnew.p=<p>
  lastnew.removefromview
  lastnew.attr=attr_invis
  lastnew.link=<uid>
  lastnew.timer=0
  tag(speedset,1)
endif

[itemdef i_speedtimer]
id=i_gold
type=t_script

on=@create
attr_Invis=1

on=@timer
link.timerd=<link.tag.hitspeed>
link.tag.remove(speedset)
remove
return 1

[function combatskill_start]
//reveal
speedtimer

tag(firststroke,1)
if (act)
 if !(act.srccombatLOS)
  sysmessage(Nevidis na cil)
  return 1
 endif
endif
return 0

[function combat_stroke]
if !(act)
 return
endif
if !(isnonmobile)
 if (tag(firststroke))//prvni stroke
  reveal
  if (profession==class_mystik)
    if(strlen(<tag(hypno_mystik)>))
    else
     if (act.srccombatLOS)&&(act.distance>1)//vidim na cil, skok k nemu, nasleduje @hittry      
       tag(mystik_storepos,<p>)
       p=<act.p>         
     endif
    endif
  endif
 else //druhej stroke (po hittry)
  //if (tag(combat_storepos))
  //  p=<tag(combat_storepos)>
  //  tag(combat_storepos,"")
  //endif 
  if (action==skill_archery)
    sebratsip(<tag(weaponuid).typedef.tdata3>)
  endif
  if (profession==class_mystik)
   if(strlen(<tag(hypno_mystik)>))
   else
    macefighting=<wrestling>
    if (act.srccombatLOS)
      if (act.isplayer) //player
        if (act.distance>=nastaveni_global_mystikrangepvp+<eval tag(rangearrowdst)>)
          return 0
        endif
      endif
        if (act.distance>=nastaveni_global_mystikrangepvm+<eval tag(rangearrowdst)>)
        return 0
      endif
      tag(mystik_storepos,<p>)
      p=<act.p>      
    endif
   endif
  endif
 endif
endif

[function sebratsip]//type
arg(sipyUID,<findtype(args)>)
if (arg(sipyUID))
  if (arg(sipyUID).amount==1)
    arg(sipyUID).arrowdrop(<act>) //a je to :)
    return 1
  else  
    arg(sipyUID).typedef.type=t_fake
    arg(sipyUID).type=t_fake
    arg(druhejsip,<findtype(args)>)
    
    if (arg(druhejsip))
      if (arg(druhejsip).baseid==arg(sipyUID).baseid) //je to ten samej druh
        if (arg(druhejsip).amount==1)
          arg(druhejsip).arrowdrop(<act>)
          arg(sipyUID).typedef.type=<args>
          arg(sipyUID).type=<args>
          return 1
        endif
      endif
    endif
    arg(sipyUID).typedef.type=<args>
    arg(sipyUID).type=<args>
  endif
endif
//consume(1 <tag(weaponuid).typedef.tdata3>)

[function arrowdrop]
if ({0 4})
  cont=<args>
  if ({0 1})
    drop
  endif
else
 remove
endif

[typedef t_fake]

[function resist_para]
return <eval(tag(resist_para)+typedef.tag(resist_para))>

[function resist_phys]
return <eval(tag(resist_phys)+typedef.tag(resist_phys))>

[function resist_blunt]
return <eval(tag(resist_blunt)+typedef.tag(resist_blunt))>

[function resist_sharp]
return <eval(tag(resist_sharp)+typedef.tag(resist_sharp))>

[function resist_slash]
return <eval(tag(resist_slash)+typedef.tag(resist_slash))>

[function resist_pierce]
return <eval(tag(resist_pierce)+typedef.tag(resist_pierce))>

[function resist_magic]
return <eval(tag(resist_magic)+typedef.tag(resist_magic))>

[function resist_poison]
return <eval(tag(resist_poison)+typedef.tag(resist_poison))>

[function resist_fire]
return <eval(tag(resist_fire)+typedef.tag(resist_fire))>

[function resist_cold]
return <eval(tag(resist_cold)+typedef.tag(resist_cold))>

[function resist_elect]
return <eval(tag(resist_elect)+typedef.tag(resist_elect))>

[function resist_acid]
return <eval(tag(resist_acid)+typedef.tag(resist_acid))>

[function resist_summon]
return <eval(tag(resist_summon)+typedef.tag(resist_summon))>

[function resist_bleed]
return <eval(tag(resist_bleed)+typedef.tag(resist_bleed))>

[function resist_dragon]
return <eval(tag(resist_dragon)+typedef.tag(resist_dragon))>


[function handleresists]//flags
arg(fl,<hval args>)

var(is_physical	,<isbit(<fl>,1)>)
var(is_magic	,<isbit(<fl>,2)>)
var(is_poison	,<isbit(<fl>,3)>)
var(is_fire	,<isbit(<fl>,4)>)
var(is_elect	,<isbit(<fl>,5)>)
//var(is_drain	,<isbit(<fl>,6)>)
var(is_acid	,<isbit(<fl>,8)>)
var(is_cold	,<isbit(<fl>,9)>)
var(is_slash	,<isbit(<fl>,10)>)
var(is_piercing	,<isbit(<fl>,11)>)
var(is_blunt	,<isbit(<fl>,12)>)
var(is_sharp	,<isbit(<fl>,13)>)
var(is_summon   ,<isbit(<fl>,14)>)
var(is_bleed   ,<isbit(<fl>,15)>)
var(is_dragon   ,<isbit(<fl>,16)>)

arg(physflags,<eval(is_blunt+is_sharp+is_slash+is_piercing+is_bleed)>)
if (physflags)
  arg(physfactor,<eval(1000*physflags)>)
  arg(physfactor,#-(resist_slash*is_slash)))
  arg(physfactor,#-(resist_pierce*is_piercing)))
  arg(physfactor,#-(resist_blunt*is_blunt))
  arg(physfactor,#-(resist_sharp*is_sharp))
  arg(physfactor,#-(resist_bleed*is_bleed))
  arg(physfactor,<eval(physfactor/physflags)>)
else
  arg(physfactor,1000)
endif
arg(physfactor,#-(resist_phys*is_physical))

arg(magflags,<eval(var(is_poison)+var(is_fire)+var(is_cold)+var(is_elect)+var(is_acid)+var(is_dragon))>)
if (magflags)
  arg(magfactor,<eval(1000*magflags)>)
  arg(magfactor,#-(resist_fire*is_fire))
  arg(magfactor,#-(resist_cold*is_cold))
  arg(magfactor,#-(resist_acid*is_acid))
  arg(magfactor,#-(resist_poison*is_poison))
  arg(magfactor,#-(resist_elect*is_elect))
  arg(magfactor,#-(resist_dragon*is_dragon))
  arg(magfactor,<eval(magfactor/magflags)>)
else
  arg(magfactor,1000)
endif
arg(magfactor,#-(resist_magic*is_magic))

arg(damfactor,<physfactor>)
if (magfactor<physfactor)
  arg(damfactor,<magfactor>)
endif
arg(damfactor,#-(resist_summon*is_summon))
//say <arg(magfactor)>::<arg(physfactor)>-><arg(damfactor)>
return <arg(damfactor)>

[eof]
