<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Shielded</name>
    </assembly>
    <members>
        <member name="T:Shielded.IShielded">
            <summary>
            The <see cref="T:Shielded.Shield"/> class tracks implementors of this interface.
            </summary>
        </member>
        <member name="P:Shielded.IShielded.Owner">
            <summary>
            The logical owner of the shielded field. Used in Committing events, since external
            users cannot access internal fields.
            </summary>
        </member>
        <member name="M:Shielded.IShielded.CanCommit(Shielded.WriteStamp)">
            <summary>
            Returns true if there have been no changes by other threads since this
            transaction opened. If so, and if the field has changes in this transaction,
            the method will also lock the field until a call to Commit or Rollback is made.
            It is called under the pre-commit lock, so it is safe, but must be quick.
            </summary>
        </member>
        <member name="T:Shielded.SideEffect">
            <summary>
            Holds a side-effect definition. They are held in one list, each element containing
            a possible OnCommit and OnRollback lambda. They will execute in the order they were
            defined.
            </summary>
        </member>
        <member name="T:Shielded.Shield">
            <summary>
            Central class of the Shielded library. Contains, among other things, methods
            for directly running transactions, and creating conditional transactions.
            </summary>
        </member>
        <member name="P:Shielded.Shield.ReadStamp">
            <summary>
            Current transaction's read stamp, i.e. the latest version it can read.
            Thread-static. Throws if called out of transaction.
            </summary>
        </member>
        <member name="P:Shielded.Shield.IsInTransaction">
            <summary>
            Gets a value indicating whether the current thread is in a transaction.
            </summary>
        </member>
        <member name="M:Shielded.Shield.AssertInTransaction">
            <summary>
            Throws <see cref="T:System.InvalidOperationException"/> if called out of a transaction.
            </summary>
        </member>
        <member name="M:Shielded.Shield.Enlist(Shielded.IShielded,System.Boolean,System.Boolean)">
            <summary>
            Enlist the specified item in the transaction. Returns true if this is the
            first time in this transaction that this item is enlisted. hasLocals indicates
            if this item already has local storage prepared. If true, it means it must have
            enlisted already. However, in IsolatedRun you may have locals, even though you
            have not yet enlisted in the isolated items! This param dictates the response
            if it is set to true, adding to the isolated items is not revealed by the retval.
            </summary>
        </member>
        <member name="M:Shielded.Shield.CheckCommutes(Shielded.IShielded)">
            <summary>
            When an item is enlisted for which we have defined commutes, it causes those
            commutes to be executed immediately. This happens before the field is read or
            written into. The algorithm here allows for one commute to trigger others,
            guaranteeing that they will all execute in correct order provided that each
            commute correctly defined the fields which, if accessed, must cause it to
            degenerate.
            </summary>
        </member>
        <member name="M:Shielded.Shield.EnlistStrictCommute(System.Action,Shielded.ICommutableShielded)">
            <summary>
            The strict version of EnlistCommute, which will monitor that the code in
            perform does not enlist anything except the one item, affecting.
            </summary>
        </member>
        <member name="M:Shielded.Shield.EnlistCommute(System.Action,Shielded.ICommutableShielded[])">
            <summary>
            The action is performed just before commit, and reads the latest
            data. If it conflicts, only it is retried. If it succeeds,
            we (try to) commit with the same write stamp along with it.
            The affecting param determines the IShieldeds that this transaction must
            not access, otherwise this commute must degenerate - it gets executed
            now, or at the moment when any of these IShieldeds enlists.
            </summary>
        </member>
        <member name="M:Shielded.Shield.Conditional(System.Func{System.Boolean},System.Action)">
            <summary>
            Conditional transaction, which executes after some fields are committed into.
            Does not execute immediately! Test is executed once just to get a read pattern,
            result is ignored. It will later be re-executed when any of the accessed
            IShieldeds commits.
            When test passes, executes trans. Test is executed in a normal transaction. If it
            changes access patterns between calls, the subscription changes as well!
            Test and trans are executed in single transaction, and if the commit fails, test
            is also retried!
            </summary>
            <returns>An IDisposable which can be used to cancel the conditional by calling
            Dispose on it. Dispose can be called from trans.</returns>
        </member>
        <member name="M:Shielded.Shield.PreCommit(System.Func{System.Boolean},System.Action)">
            <summary>
            Pre-commit check, which executes just before commit of a transaction involving
            certain fields. Can be used to ensure certain invariants hold, for example.
            Does not execute immediately! Test is executed once just to get a read pattern,
            result is ignored. It will later be re-executed just before commit of any transaction
            that changes one of the fields it accessed.
            If test passes, executes trans as well. They will execute within the transaction
            that triggers them. If they access a commuted field, the commute will degenerate.
            </summary>
            <returns>An IDisposable which can be used to cancel the pre-commit by calling
            Dispose on it. Dispose can be called from trans.</returns>
        </member>
        <member name="M:Shielded.Shield.WhenCommitting``1(System.Action{System.Collections.Generic.IEnumerable{``0}})">
            <summary>
            Execute an action during every commit which changes fields of a type.
            The action will be immediately enlisted, and get called after any commit is
            checked, but before anything is written. Any exceptions bubble out to the thread
            running the transaction (or, on calling <see cref="M:Shielded.CommitContinuation.Commit"/>).
            Calls to <see cref="M:Shielded.Shield.Rollback"/> are not allowed.
            The action may not access any fields that the transaction did not already access,
            and it may only write into fields which were already written to by the transaction.
            This method throws when called within a transaction.
            </summary>
            <returns>An IDisposable for unsubscribing.</returns>
        </member>
        <member name="M:Shielded.Shield.WhenCommitting(System.Object,System.Action{System.Boolean})">
            <summary>
            Execute an action during every writing commit which reads or changes a given field.
            The lambda receives a bool indicating whether the field has changes.
            The action will be immediately enlisted, and get called after any commit is
            checked, but before anything is written. Any exceptions bubble out to the thread
            running the transaction (or, on calling <see cref="M:Shielded.CommitContinuation.Commit"/>).
            Calls to <see cref="M:Shielded.Shield.Rollback"/> are not allowed.
            The action may not access any fields that the transaction did not already access,
            and it may only write into fields which were already written to by the transaction.
            This method throws when called within a transaction.
            </summary>
            <returns>An IDisposable for unsubscribing.</returns>
        </member>
        <member name="M:Shielded.Shield.WhenCommitting(System.Action{System.Collections.Generic.IEnumerable{Shielded.TransactionField}})">
            <summary>
            Execute an action during every writing commit.
            The action will be immediately enlisted, and get called after any commit is
            checked, but before anything is written. Any exceptions bubble out to the thread
            running the transaction (or, on calling <see cref="M:Shielded.CommitContinuation.Commit"/>).
            Calls to <see cref="M:Shielded.Shield.Rollback"/> are not allowed.
            The action may not access any fields that the transaction did not already access,
            and it may only write into fields which were already written to by the transaction.
            This version receives a full list of enlisted items, even those without changes.
            This method throws when called within a transaction.
            </summary>
            <returns>An IDisposable for unsubscribing.</returns>
        </member>
        <member name="M:Shielded.Shield.SideEffect(System.Action,System.Action)">
            <summary>
            Enlists a side-effect - an operation to be performed only if the transaction
            commits. Optionally receives an action to perform in case of a rollback.
            If the transaction is rolled back, all enlisted side-effects are (also) cleared.
            Should be used to perform all IO and such operations (except maybe logging).
            
            If this is called out of transaction, the fx action (if one was provided)
            will be directly executed. This preserves correct behavior if the call finds
            itself sometimes in, sometimes out of transaction, because of some crazy
            nesting differences.
            </summary>
        </member>
        <member name="M:Shielded.Shield.SyncSideEffect(System.Action)">
            <summary>
            Enlists a synchronized side effect. Such side effects are executed during a
            commit, when individual transactional fields are still locked. They run just
            before any triggered <see cref="M:Shielded.Shield.WhenCommitting(System.Object,System.Action{System.Boolean})"/> subscriptions, under the
            same conditions as they do. This can only be called within transactions.
            If the transaction is read-only, this will still work, but it will not be in
            sync with anything - please note that a read-only transaction locks nothing.
            </summary>
        </member>
        <member name="M:Shielded.Shield.InTransaction``1(System.Func{``0})">
            <summary>
            Executes the function in a transaction, and returns its final result.
            Transactions may, in case of conflicts, get repeated from beginning. Your
            delegate should be ready for this. If you wish to do IO or similar
            operations, which should not be repeated, pass them to
            <see cref="M:Shielded.Shield.SideEffect(System.Action,System.Action)"/>. Nesting InTransaction calls is allowed,
            the nested transactions are treated as normal parts of the outer transaction.
            </summary>
        </member>
        <member name="M:Shielded.Shield.InTransaction(System.Action)">
            <summary>
            Executes the action in a transaction.
            Transactions may, in case of conflicts, get repeated from beginning. Your
            delegate should be ready for this. If you wish to do IO or similar
            operations, which should not be repeated, pass them to
            <see cref="M:Shielded.Shield.SideEffect(System.Action,System.Action)"/>. Nesting InTransaction calls is allowed,
            the nested transactions are treated as normal parts of the outer transaction.
            </summary>
        </member>
        <member name="M:Shielded.Shield.RunToCommit(System.Int32,System.Action)">
            <summary>
            Runs a transaction, with repetitions if needed, until it passes the commit check,
            and then stops. The fields that will be written into, remain locked! It returns
            an object which can be used to later commit the transaction, roll it back, or run
            code inside of its scope, restricted to fields touched by the original transaction.
            Receives a timeout in milliseconds, and the returned continuation will, if not
            completed by then, automatically roll back by this time.
            </summary>
        </member>
        <member name="M:Shielded.Shield.Rollback">
            <summary>
            Rolls the transaction back and retries it from the beginning. If you don't
            want the transaction to repeat, throw and catch an exception yourself.
            </summary>
        </member>
        <member name="M:Shielded.Shield.ReadOldState(System.Action)">
            <summary>
            Executes the delegate in a context where every read returns the value as
            it was at transaction opening. Writes still work, even though their
            effects cannot be seen in this context. And please note that
            <see cref="M:Shielded.Shielded`1.Modify(Shielded.Shielded{`0}.ModificationDelegate)"/> will not be affected and will expose
            the last written value.
            </summary>
        </member>
        <member name="M:Shielded.Shield.IsolatedRun(System.Action)">
            <summary>
            Runs the action, and returns a set of IShieldeds that the action enlisted.
            It will make sure to restore original enlisted items, merged with the ones
            that the action enlisted, before returning. This is important to make sure
            all thread-local state is cleared on transaction exit. The isolated action
            may still cause outer transaction's commutes to degenerate.
            </summary>
        </member>
        <member name="M:Shielded.Shield.RunCommutes(Shielded.TransItems@)">
            <summary>
            Executes the commutes, returning through the out param the set of items that the
            commutes had accessed.
            Increases the current start stamp, and leaves the commuted items unmerged with the
            main transaction items!
            </summary>
        </member>
        <member name="M:Shielded.Shield.CommitCheck">
            <summary>
            Performs the commit check, returning the outcome. Prepares the write ticket in the context.
            The ticket is obtained before leaving the lock here, so that any thread which
            later conflicts with us will surely (in its retry) read the version we are now
            writing. The idea is to avoid senseless repetitions, retries after which a
            thread would again read old data and be doomed to fail again.
            It is critical that this ticket be marked when complete (i.e. Changes set to
            something non-null), because trimming will not go past it until this happens.
            </summary>
        </member>
        <member name="T:Shielded.Shielded`1">
            <summary>
            Makes your data thread safe. Works with structs, or simple value types,
            and the language does the necessary cloning. If T is a class, then only
            the reference itself is protected.
            </summary>
        </member>
        <member name="M:Shielded.Shielded`1.#ctor(System.Object)">
            <summary>
            Constructs a new Shielded container, containing default value of type T.
            </summary>
            <param name="owner">If this is given, then in WhenCommitting subscriptions
            this shielded will report its owner instead of itself.</param>
        </member>
        <member name="M:Shielded.Shielded`1.#ctor(`0,System.Object)">
            <summary>
            Constructs a new Shielded container, containing the given initial value.
            </summary>
            <param name="initial">Initial value to contain.</param>
            <param name="owner">If this is given, then in WhenCommitting subscriptions
            this shielded will report its owner instead of itself.</param>
        </member>
        <member name="M:Shielded.Shielded`1.CheckLockAndEnlist(System.Boolean)">
            <summary>
            Enlists the field in the current transaction and, if this is the first
            access, checks the write lock. Will wait (using StampLocker) if the write
            stamp &lt;= <see cref="P:Shielded.Shield.ReadStamp"/>, until write lock is released.
            Since write stamps are increasing, this is likely to happen only at the
            beginning of transactions.
            </summary>
        </member>
        <member name="M:Shielded.Shielded`1.GetOldValue">
            <summary>
            Gets the value that this Shielded contained at transaction opening. During
            a transaction, this is constant. See also <see cref="M:Shielded.Shield.ReadOldState(System.Action)"/>.
            </summary>
        </member>
        <member name="P:Shielded.Shielded`1.Value">
            <summary>
            Reads or writes into the content of the field. Reading can be
            done out of transaction, but writes must be inside.
            </summary>
        </member>
        <member name="T:Shielded.Shielded`1.ModificationDelegate">
            <summary>
            Delegate type used for modifications, i.e. read and write operations.
            It has the advantage of working directly on the internal, thread-local
            storage copy, to which it gets a reference. This is more efficient if
            the type T is a big value-type.
            </summary>
        </member>
        <member name="M:Shielded.Shielded`1.Modify(Shielded.Shielded{`0}.ModificationDelegate)">
            <summary>
            Modifies the content of the field, i.e. read and write operation.
            It has the advantage of working directly on the internal, thread-local
            storage copy, to which it gets a reference. This is more efficient if
            the type T is a big value-type.
            </summary>
        </member>
        <member name="M:Shielded.Shielded`1.Commute(Shielded.Shielded{`0}.ModificationDelegate)">
            <summary>
            The action is performed just before commit, and reads the latest
            data. If it conflicts, only it is retried. If it succeeds,
            we (try to) commit with the same write stamp along with it.
            But, if you access this Shielded, it gets executed directly in this transaction.
            The Changed event is raised only when the commute is enlisted, and not
            when (and every time, given possible repetitions..) it executes.
            </summary>
        </member>
        <member name="M:Shielded.Shielded`1.Commute(System.Action)">
            <summary>
            For use by the ProxyGen, since the users of it know only about the base type used
            to generate the proxy. The struct used internally is not exposed, and so users
            of proxy classes could not write a ModificationDelegate which works on an argument
            whose type is that hidden struct.
            </summary>
        </member>
        <member name="F:Shielded.Shielded`1.Changed">
            <summary>
            Event raised after any change, and directly in the transaction that changed it.
            Subscriptions are transactional. In case of a commute, event is raised immediately
            after the commute is enlisted, and your handler can easily cause commutes to
            degenerate.
            </summary>
        </member>
        <member name="M:Shielded.Shielded`1.op_Implicit(Shielded.Shielded{`0})~`0">
            <summary>
            Returns the current <see cref="P:Shielded.Shielded`1.Value"/>.
            </summary>
        </member>
        <member name="T:Shielded.ShieldedSeq`1">
            <summary>
            Supports adding at both ends O(1), taking from head O(1), and every other op
            involves a search, O(n). Enumerating must be done in transaction, unless you
            read only one element, e.g. using LINQ Any or First.
            For a faster version, but with no Count property, see <see cref="T:Shielded.ShieldedSeqNc`1"/>.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.#ctor(`0[],System.Object)">
            <summary>
            Initialize a new sequence with the given initial contents, and optionally
            an "owner" - this seq will then report that object to WhenSubmitting subscriptions.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.#ctor(`0[])">
            <summary>
            Initialize a new sequence with the given initial contents.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.Prepend(`0)">
            <summary>
            Prepend an item, i.e. insert at index 0.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedSeq`1.Head">
            <summary>
            Peek at the first element. Throws <see cref="T:System.InvalidOperationException"/> if
            there is none.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.TakeHead">
            <summary>
            Remove the first element of the sequence, and return it.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedSeq`1.Consume">
            <summary>
            Remove and yield elements from the head of the sequence.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.Append(`0)">
            <summary>
            Append the specified value, commutatively - if you don't / haven't touched the
            sequence in this transaction (using other methods/properties), this will not cause
            conflicts! Effectively, the value is simply appended to whatever the sequence
            is at commit time. Multiple calls to Append made in one transaction will
            append the items in that order - they commute with other transactions only.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedSeq`1.Item(System.Int32)">
            <summary>
            Get or set the item at the specified index. This iterates through the internal
            linked list, so it is not efficient for large sequences.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedSeq`1.Count">
            <summary>
            Get the number of items in this sequence.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.RemoveAll(System.Func{`0,System.Boolean})">
            <summary>
            Remove from the sequence all items that satisfy the given predicate.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.Clear">
            <summary>
            Clear the sequence.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at the given index.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Remove the specified item from the sequence.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.IndexOf(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Search the sequence for the given item.
            </summary>
            <returns>The index of the item in the sequence.</returns>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.IndexOf(`0)">
            <summary>
            Search the sequence for the given item.
            </summary>
            <returns>The index of the item in the sequence.</returns>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.GetEnumerator">
            <summary>
            Get an enumerator for the sequence. Although it is just a read, it must be
            done in a transaction since concurrent changes would make the result unstable.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.Add(`0)">
            <summary>
            Add the specified item to the end of the sequence. Same as <see cref="M:Shielded.ShieldedSeq`1.Append(`0)"/>,
            so, it's commutable.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.Contains(`0)">
            <summary>
            Check if the sequence contains a given item.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the sequence to an array.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="arrayIndex">Index in the array where to begin the copy.</param>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.Remove(`0)">
            <summary>
            Remove the specified item from the sequence.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeq`1.Insert(System.Int32,`0)">
            <summary>
            Insert an item at the specified index.
            </summary>
        </member>
        <member name="T:Shielded.ShieldedTree`2">
            <summary>
            A shielded red-black tree, for keeping sorted data. Each node is a
            Shielded struct, so parallel operations are possible. Multiple items
            may be added under the same key.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTree`2.#ctor(System.Collections.Generic.IComparer{`0},System.Object)">
            <summary>
            Initializes a new tree, which will use a given comparer, or using the .NET default
            comparer if none is specified.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTree`2.OnInsert">
            <summary>
            Called after inserting a new node.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTree`2.OnRemove">
            <summary>
            Called after a node is removed from the tree.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTree`2.Clear">
            <summary>
            Clear this instance. Efficient, O(1).
            </summary>
        </member>
        <member name="P:Shielded.ShieldedTree`2.Count">
            <summary>
            Gets the number of items in the tree.
            </summary>
        </member>
        <member name="T:Shielded.ShieldedEvent`1">
            <summary>
            Similar to an ordinary .NET event, except that subscribing and unsubscribing
            is transactional. This means, for example, that you will not get events until
            your transaction, which makes the subscription, has committed. After that, you
            are guaranteed to get all of them! (Any transaction which should have raised it
            will be in conflict with your transaction, will be retried, and then will raise
            the event!) The event is raised directly - all handlers run on the same thread
            and inside the transaction that triggers them.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedEvent`1.Subscribe(System.EventHandler{`0})">
            <summary>
            Subscribe a new event handler.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedEvent`1.Unsubscribe(System.EventHandler{`0})">
            <summary>
            Unsubscribe the specified handler.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedEvent`1.Raise(System.Object,`0)">
            <summary>
            Raise the event with the given arguments.
            </summary>
        </member>
        <member name="M:Shielded.Actions.SafeRun(System.Collections.Generic.IEnumerable{System.Action})">
            <summary>
            Executes an IEnumerable of actions, each in its own try/catch block. If any
            throw, it will still run every one, and then afterwards throw an
            AggregateException.
            </summary>
        </member>
        <member name="M:Shielded.Actions.Run(System.Collections.Generic.IEnumerable{System.Action})">
            <summary>
            Executes an IEnumerable of actions, with no special handling. First exception
            interrupts it.
            </summary>
        </member>
        <member name="M:Shielded.SimpleHashSet.CanCommit(Shielded.WriteStamp)">
            <summary>
            Performs the commit check on the enlisted items.
            </summary>
        </member>
        <member name="M:Shielded.SimpleHashSet.Commit">
            <summary>
            Commits the enlisted items.
            </summary>
        </member>
        <member name="M:Shielded.SimpleHashSet.CommitWoChanges">
            <summary>
            Commits items without preparing a list of changed ones, to use
            when you know that there are no changes.
            </summary>
        </member>
        <member name="M:Shielded.SimpleHashSet.Rollback">
            <summary>
            Rolls the enlisted items back.
            </summary>
        </member>
        <member name="M:Shielded.SimpleHashSet.TrimCopies(System.Int64)">
            <summary>
            Helper for trimming.
            </summary>
        </member>
        <member name="T:Shielded.WriteStamp">
            <summary>
            Contains information on the thread that has locked an object.
            </summary>
        </member>
        <member name="F:Shielded.WriteStamp.Locker">
            <summary>
            Reference to the locking transaction. Useful to make sure that
            a thread, on rollback, releases only those locks it made.
            </summary>
        </member>
        <member name="F:Shielded.WriteStamp.Version">
            <summary>
            The version of the data that is about to be written into the
            locked object. All threads which should be able to read this
            version (i.e. their <see cref="P:Shielded.Shield.ReadStamp"/> is greater
            or equal to this value) must wait for the lock to be released.
            If the value is null, then this lock is still being checked and
            the reader may proceed - when/if it passes check, it will certainly
            get a higher value than current reader's read stamp.
            </summary>
        </member>
        <member name="T:Shielded.ReadTicket">
            <summary>
            Issued by the <see cref="T:Shielded.VersionList"/> static class, tells holders
            which version of data they should read. The VersionList will
            keep track of issued tickets for the purpose of safe trimming of
            old versions.
            </summary>
        </member>
        <member name="P:Shielded.ReadTicket.Stamp">
            <summary>
            The version number of the ticket.
            </summary>
        </member>
        <member name="T:Shielded.WriteTicket">
            <summary>
            Issued by the <see cref="T:Shielded.VersionList"/> static class to writers, telling
            them which version number to use when writing, and allwing them to
            report changes they make back to the VersionList.
            </summary>
        </member>
        <member name="F:Shielded.WriteTicket.Changes">
            <summary>
            After writers complete a write, they must place into this field
            an enumerable of the fields they changed. Needed for trimming old
            versions. It is crucial to set it to something != null, otherwise
            trimming will never get past this version!
            </summary>
        </member>
        <member name="T:Shielded.VersionList">
            <summary>
            This class handles everything about assigning version stamps to readers and
            writers, and takes care of determining what is the minimum used stamp, so that
            old unreachable versions can be released to the GC.
            </summary>
        </member>
        <member name="M:Shielded.VersionList.GetReaderTicket(Shielded.ReadTicket@)">
            <summary>
            Reader should keep a reference to his ticket, and release it with a call
            to <see cref="M:Shielded.VersionList.ReleaseReaderTicket(Shielded.ReadTicket@)"/> when done.
            </summary>
        </member>
        <member name="M:Shielded.VersionList.GetUntrackedReadStamp">
            <summary>
            For commute running block, because it knows that the ticket taken by
            the main transaction is all the protection it needs.
            </summary>
        </member>
        <member name="M:Shielded.VersionList.ReleaseReaderTicket(Shielded.ReadTicket@)">
            <summary>
            After no reading will be done for the given reader ticket, release it with this method.
            </summary>
        </member>
        <member name="M:Shielded.VersionList.NewVersion(Shielded.WriteStamp,Shielded.WriteTicket@)">
            <summary>
            Called after a thread checked and can commit. This will assign it a
            unique stamp to use for writing. This method will enter the new stamp
            into the stamp.Version. It must be done here to guarantee that no
            GetReaderTicket will return your stamp number before it has been
            written into your stamp lock! After completing your write, place your
            changes into the ticket, and this class will trim the old versions at
            the correct time. It is critical that this be done, which is why this
            method returns it as an out param - to make sure no exception can
            cause us to lose the ref to the ticket, if it is already in the chain.
            </summary>
        </member>
        <member name="T:Shielded.ProxyGen.Factory">
            <summary>
            Factory for generating Shielded proxy-subclasses for POCO classes.
            </summary>
        </member>
        <member name="M:Shielded.ProxyGen.Factory.ShieldedType(System.Type)">
            <summary>
            Returns the proxy subtype for a given type. If arg already is a proxy type,
            then it just returns it directly. The proxy type implements backing storage
            for all virtual properties (with virtual getters and setters) in one
            Shielded struct container. Base setters will be called before any change,
            and may use the getter to obtain the old value.
            If the class has a virtual method Commute(Action), this will be overriden
            and the override will perform the action as a commute.
            If the class has a protected method OnChanged(string), this will be called
            after every property change, with the property name as argument.
            The subtype is generated once per type, and cached for future calls.
            </summary>
        </member>
        <member name="M:Shielded.ProxyGen.Factory.NewShielded``1">
            <summary>
            Constructs a new instance of the subtype of T generated by
            <see cref="M:Shielded.ProxyGen.Factory.ShieldedType(System.Type)"/>. It implements backing storage
            for all virtual properties (with virtual getters and setters) in one
            Shielded struct container. Base setters will be called before any change,
            and may use the getter to obtain the old value.
            If the class has a virtual method Commute(Action), this will be overriden
            and the override will perform the action as a commute.
            If the class has a protected method OnChanged(string), this will be called
            after every property change, with the property name as argument.
            The subtype is generated once per type, and cached for future calls.
            </summary>
        </member>
        <member name="M:Shielded.ProxyGen.Factory.CanGenerateProxy(System.Type)">
            <summary>
            Returns true if we can generate a proxy subclass for the given type.
            It would be recommended not to use this when preparing types - try to
            prepare every type you think should be prepared. That way, if one of your
            types is not OK, you will get an exception at preparation time, rather
            than later, when some piece of code tries to use the factory to construct
            one of those types.
            </summary>
        </member>
        <member name="M:Shielded.ProxyGen.Factory.IsProxy(System.Type)">
            <summary>
            Returns true if the type is a shielded proxy type.
            </summary>
        </member>
        <member name="M:Shielded.ProxyGen.Factory.PrepareTypes(System.Type[])">
            <summary>
            Prepares proxy subclasses for given types, all in one new assembly. (Normally,
            when doing one by one, each gets its own assembly.) If any of the types is
            not suitable, you will get an <see cref="T:System.InvalidOperationException"/>.
            </summary>
        </member>
        <member name="M:Shielded.ProxyGen.ProxyGen.Prepare(System.Type[])">
            <summary>
            Prepare the specified types.
            </summary>
        </member>
        <member name="T:Shielded.ProxyGen.ProxyGenerationException">
            <summary>
            Exception thrown when an error occurs during CodeDOM compilation.
            </summary>
        </member>
        <member name="M:Shielded.ProxyGen.ProxyGenerationException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:Shielded.ProxyGen.ProxyGenerationException"/> class.
            </summary>
        </member>
        <member name="M:Shielded.ProxyGen.ProxyGenerationException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:Shielded.ProxyGen.ProxyGenerationException"/> class.
            </summary>
            <param name="message">Message describing the error(s).</param>
        </member>
        <member name="M:Shielded.ProxyGen.ProxyGenerationException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:Shielded.ProxyGen.ProxyGenerationException"/> class.
            </summary>
            <param name="message">Message describing the error(s).</param>
            <param name="inner">Inner exception.</param>
        </member>
        <member name="M:Shielded.ProxyGen.ProxyGenerationException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            Initializes a new instance of the <see cref="T:Shielded.ProxyGen.ProxyGenerationException"/> class
            based on serialized information.
            </summary>
        </member>
        <member name="M:Shielded.TransItems.UnionWith(Shielded.TransItems)">
            <summary>
            Unions the other items into this. Does not include commutes!
            </summary>
        </member>
        <member name="F:Shielded.CommuteState.Broken">
            <summary>
            Commute must execute due to transaction accessing a field it works on.
            </summary>
        </member>
        <member name="F:Shielded.CommuteState.Executed">
            <summary>
            Commute was executed.
            </summary>
        </member>
        <member name="F:Shielded.Commute.Perform">
            <summary>
            The commutable action.
            </summary>
        </member>
        <member name="F:Shielded.Commute.Affecting">
            <summary>
            The fields which, if enlisted by the main transaction, must cause the commute to
            execute in-transaction.
            </summary>
        </member>
        <member name="F:Shielded.Commute.State">
            <summary>
            The state of the commute.
            </summary>
        </member>
        <member name="T:Shielded.TransactionField">
            <summary>
            A descriptor for some object taking part in a transaction.
            </summary>
        </member>
        <member name="F:Shielded.TransactionField.Field">
            <summary>
            The object which enlisted in the transaction.
            </summary>
        </member>
        <member name="F:Shielded.TransactionField.HasChanges">
            <summary>
            If the given object has any changes.
            </summary>
        </member>
        <member name="M:Shielded.TransactionField.#ctor(System.Object,System.Boolean)">
            <summary>
            Constructor.
            </summary>
        </member>
        <member name="T:Shielded.CommitSubscription">
            <summary>
            Contains information about a commit subscription, used in implementing
            <see cref="M:Shielded.Shield.Conditional(System.Func{System.Boolean},System.Action)"/> and <see cref="M:Shielded.Shield.PreCommit(System.Func{System.Boolean},System.Action)"/>.
            </summary>
        </member>
        <member name="M:Shielded.CommitSubscription.UpdateEntries">
            <summary>
            Updates our entries in the dictionary. To be immediately visible as soon as
            the _items.CanCommit() passes, we add ourselves into the dict straight away,
            and in a side effect we remove unnecessary entries, or, on rollback, undo
            the early additions.
            </summary>
        </member>
        <member name="M:Shielded.CommitSubscriptionContext.Trigger(System.Collections.Generic.IEnumerable{Shielded.IShielded})">
            <summary>
            Prepares subscriptions for execution based on the items that were committed.
            </summary>
        </member>
        <member name="T:Shielded.ShieldedDictNc`2">
            <summary>
            A transactional dictionary - adding, removing, replacing items are transactional,
            but anything done to the items is not unless they are Shielded themselves. The 'Nc' stands
            for 'no count' - you cannot find out how many items it has, unless you enumerate.
            WARNING: Enumerating transactions will not conflict with parallel transactions which
            add new items to the dictionary. This is OK for read-only transactions, but writers
            might successfully commit some result even though they did not see all items.
            For fully safe enumerating, please use <see cref="T:Shielded.ShieldedDict`2"/>.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDictNc`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Object)">
            <summary>
            Initializes a new instance with the given initial contents.
            </summary>
            <param name="items">Initial items.</param>
            <param name="owner">If this is given, then in WhenCommitting subscriptions
            this shielded will report its owner instead of itself.</param>
        </member>
        <member name="M:Shielded.ShieldedDictNc`2.CheckLockedAccess(`0,System.Boolean)">
            <summary>
            Since the dictionary is just one field to the Shield class, we internally check, if
            the access is happening while locked, whether the access is safe.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDictNc`2.PrepareWrite(`0)">
            <summary>
            Returns an existing local entry, if any.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedDictNc`2.Item(`0)">
            <summary>
            Gets or sets the value under the specified key.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedDictNc`2.Changes">
            <summary>
            An enumerable of keys for which the current transaction made changes in the dictionary.
            Safely accessible from <see cref="M:Shielded.Shield.WhenCommitting(System.Object,System.Action{System.Boolean})"/> subscriptions. NB that
            this also includes keys which were removed from the dictionary.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedDictNc`2.Reads">
            <summary>
            An enumerable of keys which the current transaction read or wrote into.
            Safely accessible from <see cref="M:Shielded.Shield.WhenCommitting(System.Object,System.Action{System.Boolean})"/> subscriptions. NB that
            this also includes keys which were removed from the dictionary.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDictNc`2.GetEnumerator">
            <summary>
            Get an enumerator for the dictionary contents. Iterating over this dictionary
            does not conflict with other transactions that are adding new items, so it
            is not fully safe. For read-only transactions, however, no problem.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDictNc`2.Clear">
            <summary>
            Removes all items, but one by one.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDictNc`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copy the dictionary contents to an array. Involves enumerating, might not get all
            items which should have been visible at the time of your commit. This does not
            affect read-only transactions, or those writers that do not logically depend on
            seeing all items.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDictNc`2.Add(`0,`1)">
            <summary>
            Add the specified key and value to the dictionary.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if the key is already present in the dictionary.</exception>
        </member>
        <member name="M:Shielded.ShieldedDictNc`2.ContainsKey(`0)">
            <summary>
            Check if the dictionary contains the given key.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDictNc`2.Remove(`0)">
            <summary>
            Remove the specified key from the collection.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDictNc`2.TryGetValue(`0,`1@)">
            <summary>
            Safe read based on the key - returns true if the key is present, and
            then also returns the value stored under that key through the out parameter.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedDictNc`2.Keys">
            <summary>
            Get a collection of all the keys in the dictionary. Can be used out of transactions.
            The result is a copy, it will not be updated if the dictionary is later changed.
            Like all enumerating operations on this type, it is not completely safe, unless
            your transaction is read-only.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedDictNc`2.Values">
            <summary>
            Get a collection of all the values in the dictionary. Can be used out of transactions.
            The result is a copy, it will not be updated if the dictionary is later changed.
            Like all enumerating operations on this type, it is not completely safe, unless
            your transaction is read-only.
            </summary>
        </member>
        <member name="T:Shielded.ShieldedDict`2">
            <summary>
            A transactional dictionary - adding, removing, replacing items are transactional,
            but anything done to the items is not unless they are Shielded themselves.
            Enumerating over this dictionary is safe, but it is a very conflicting operation.
            Any add/remove committed in parallel will cause an enumerating transaction to
            rollback. For a faster variant, but without a counter and less safe for enumerating,
            see <see cref="T:Shielded.ShieldedDictNc`2"/>.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDict`2.#ctor(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{`0,`1}},System.Object)">
            <summary>
            Initializes a new instance with the given initial contents.
            </summary>
            <param name="items">Initial items.</param>
            <param name="owner">If this is given, then in WhenCommitting subscriptions
            this shielded will report its owner instead of itself.</param>
        </member>
        <member name="P:Shielded.ShieldedDict`2.Changes">
            <summary>
            An enumerable of keys for which the current transaction made changes in the dictionary.
            Safely accessible from <see cref="M:Shielded.Shield.WhenCommitting(System.Object,System.Action{System.Boolean})"/> subscriptions. NB that
            this also includes keys which were removed from the dictionary.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedDict`2.Reads">
            <summary>
            An enumerable of keys which the current transaction read or wrote into.
            Safely accessible from <see cref="M:Shielded.Shield.WhenCommitting(System.Object,System.Action{System.Boolean})"/> subscriptions. NB that
            this also includes keys which were removed from the dictionary.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDict`2.Add(`0,`1)">
            <summary>
            Add the specified key and value to the dictionary.
            </summary>
            <exception cref="T:System.ArgumentException">Thrown if the key is already present in the dictionary.</exception>
        </member>
        <member name="M:Shielded.ShieldedDict`2.ContainsKey(`0)">
            <summary>
            Check if the dictionary contains the given key.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDict`2.Remove(`0)">
            <summary>
            Remove the specified key from the collection.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDict`2.TryGetValue(`0,`1@)">
            <summary>
            Safe read based on the key - returns true if the key is present, and
            then also returns the value stored under that key through the out parameter.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedDict`2.Item(`0)">
            <summary>
            Get or set the value under the specified key.
            </summary>
            <param name="key">Key.</param>
        </member>
        <member name="P:Shielded.ShieldedDict`2.Keys">
            <summary>
            Get a collection of all the keys in the dictionary. Can be used out of transactions.
            The result is a copy, it will not be updated if the dictionary is later changed.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedDict`2.Values">
            <summary>
            Get a collection of all the values in the dictionary. Can be used out of transactions.
            The result is a copy, it will not be updated if the dictionary is later changed.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDict`2.Clear">
            <summary>
            Removes all items, but one by one.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedDict`2.Count">
            <summary>
            Gets the number of items in the dictionary.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedDict`2.GetEnumerator">
            <summary>
            Get an enumerator for the dictionary contents. Iterating over this dictionary
            conflicts with transactions that are adding items to the dictionary, and is
            fully safe.
            </summary>
        </member>
        <member name="T:Shielded.ShieldedSeqNc`1">
            <summary>
            Supports adding at both ends O(1), taking from head O(1), and every other op
            involves a search, O(n). Enumerating must be done in transaction, unless you
            read only one element, e.g. using LINQ Any or First.
            The 'Nc' stands for 'no count' - the number of items can only be obtained by
            enumerating. This enables it to be faster in other ops, since counters are
            very contentious.
            For a sequence with a counter, see <see cref="T:Shielded.ShieldedSeq`1"/>.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.#ctor(`0[],System.Object)">
            <summary>
            Initialize a new sequence with the given initial contents.
            </summary>
            <param name="items">Initial items.</param>
            <param name="owner">If this is given, then in WhenCommitting subscriptions
            this shielded will report its owner instead of itself.</param>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.#ctor(`0[])">
            <summary>
            Initialize a new sequence with the given initial contents.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.Prepend(`0)">
            <summary>
            Prepend an item, i.e. insert at index 0.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedSeqNc`1.Head">
            <summary>
            Peek at the first element. Throws <see cref="T:System.InvalidOperationException"/> if
            there is none.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.TakeHead">
            <summary>
            Remove the first element of the sequence, and return it.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedSeqNc`1.Consume">
            <summary>
            Remove and yield elements from the head of the sequence.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.Append(`0)">
            <summary>
            Append the specified value, commutatively - if you don't / haven't touched the
            sequence in this transaction (using other methods/properties), this will not cause
            conflicts! Effectively, the value is simply appended to whatever the sequence
            is at commit time. Multiple calls to Append made in one transaction will
            append the items in that order - they commute with other transactions only.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedSeqNc`1.Item(System.Int32)">
            <summary>
            Get or set the item at the specified index. This iterates through the internal
            linked list, so it is not efficient for large sequences.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.RemoveAll(System.Func{`0,System.Boolean})">
            <summary>
            Remove from the sequence all items that satisfy the given predicate.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.RemoveAll(System.Func{`0,System.Boolean},System.Int32@)">
            <summary>
            Remove from the sequence all items that satisfy the given predicate.
            Returns the number of removed items in an out param, guaranteed to
            equal actual number of removed items even if the condition lambda throws.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.Clear">
            <summary>
            Clear the sequence.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.RemoveAt(System.Int32)">
            <summary>
            Remove the item at the given index.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.Remove(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Remove the specified item from the sequence.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.IndexOf(`0,System.Collections.Generic.IEqualityComparer{`0})">
            <summary>
            Search the sequence for the given item.
            </summary>
            <returns>The index of the item in the sequence, or -1 if not found.</returns>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.GetEnumerator">
            <summary>
            Get an enumerator for the sequence. Although it is just a read, it must be
            done in a transaction since concurrent changes would make the result unstable.
            However, if you just read the first item (e.g. by calling Any or First), that
            will work out of transaction too.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.Add(`0)">
            <summary>
            Add the specified item to the end of the sequence. Same as <see cref="M:Shielded.ShieldedSeqNc`1.Append(`0)"/>,
            so, it's commutable.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.Contains(`0)">
            <summary>
            Check if the sequence contains a given item.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.CopyTo(`0[],System.Int32)">
            <summary>
            Copy the sequence to an array.
            </summary>
            <param name="array">The array to copy to.</param>
            <param name="arrayIndex">Index in the array where to begin the copy.</param>
        </member>
        <member name="M:Shielded.ShieldedSeqNc`1.Insert(System.Int32,`0)">
            <summary>
            Insert an item at the specified index.
            </summary>
        </member>
        <member name="T:Shielded.ShieldedTreeNc`2">
            <summary>
            A shielded red-black tree, for keeping sorted data. Each node is a
            Shielded struct, so parallel operations are possible. Multiple items
            may be added under the same key. 'Nc' stands for 'no count', which
            enables it to be a bit faster.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.#ctor(System.Collections.Generic.IComparer{`0},System.Object)">
            <summary>
            Initializes a new tree, which will use a given comparer, or using the .NET default
            comparer if none is specified.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.GetEnumerator">
            <summary>
            Gets an enumerator for all the key-value pairs in the tree.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedTreeNc`2.Descending">
            <summary>
            Gets an enuerable which enumerates the tree in descending key order. (Does not
            involve any copying, just as efficient as <see cref="M:Shielded.ShieldedTreeNc`2.GetEnumerator"/>.)
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.Range(`0,`0)">
            <summary>
            Enumerate all key-value pairs, whose keys are in the given range. The range
            is inclusive, both from and to are included in the result (if the tree contains
            those keys). The items are returned sorted. If from is greater than to, the
            enumerable will not return anything. For backwards enumeration you must explicitly
            use <see cref="M:Shielded.ShieldedTreeNc`2.RangeDescending(`0,`0)"/>.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.RangeInternal(`0,`0)">
            <summary>
            Enumerates only over the nodes in the range. Borders included.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.RangeDescending(`0,`0)">
            <summary>
            Enumerate all key-value pairs, whose keys are in the given range, but in descending
            key order. The range is inclusive, both from and to are included in the result (if
            the tree contains those keys). If from is smaller than to, the enumerable will not
            return anything. For forward enumeration you must explicitly use <see cref="M:Shielded.ShieldedTreeNc`2.Range(`0,`0)"/>.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.OnInsert">
            <summary>
            Called after inserting a new node.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.RemoveAndReturn(`0,`1@)">
            <summary>
            Removes an item and returns it. Useful if you could have multiple items under the same key.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.OnRemove">
            <summary>
            Called after a node is removed from the tree.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.Clear">
            <summary>
            Clear this instance. Efficient, O(1).
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.Contains(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Checks both the key and value, which may be useful due to the tree supporting multiple
            entries with the same key.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.CopyTo(System.Collections.Generic.KeyValuePair{`0,`1}[],System.Int32)">
            <summary>
            Copy the tree contents into an array.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.Remove(System.Collections.Generic.KeyValuePair{`0,`1})">
            <summary>
            Remove the given key-value pair from the tree. Checks both the key and
            value, which may be useful due to the tree supporting multiple entries
            with the same key.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.Add(`0,`1)">
            <summary>
            Add the given key and value to the tree. Same key can be added multiple times
            into the tree!
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.ContainsKey(`0)">
            <summary>
            Check if the key is present in the tree.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.Remove(`0)">
            <summary>
            Remove an item with the specified key. If you want to know what got removed, use
            RemoveAndReturn.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedTreeNc`2.TryGetValue(`0,`1@)">
            <summary>
            Try to get any one of the values stored under the given key. There may be multiple items
            under the same key!
            </summary>
        </member>
        <member name="P:Shielded.ShieldedTreeNc`2.Item(`0)">
            <summary>
            Gets or sets the item with the specified key.
            If there are many with the same key, acts on the first one it finds!
            </summary>
        </member>
        <member name="P:Shielded.ShieldedTreeNc`2.Keys">
            <summary>
            Get a collection of the keys in the tree. Works out of transaction.
            The result is a copy, it does not get updated with later changes.
            Count will be equal to the tree count, i.e. if there are multiple
            entries with the same key, that key will be in this collection
            multiple times.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedTreeNc`2.Values">
            <summary>
            Get a collection of the values in the tree. Works out of transaction.
            The result is a copy, it does not get updated with later changes.
            </summary>
        </member>
        <member name="T:Shielded.CommitContinuation">
            <summary>
            An object used to commit a transaction at a later time, or from another
            thread. Returned by <see cref="M:Shielded.Shield.RunToCommit(System.Int32,System.Action)"/>. The transaction has
            been checked, and is OK to commit. This class is thread-safe - it makes
            sure only one thread can initiate a commit, but any number of threads
            may try a rollback in parallel.
            </summary>
        </member>
        <member name="P:Shielded.CommitContinuation.Completed">
            <summary>
            True if <see cref="M:Shielded.CommitContinuation.Commit"/> or <see cref="M:Shielded.CommitContinuation.Rollback"/> have completed.
            Volatile and set last, so after this becomes true, <see cref="P:Shielded.CommitContinuation.Committed"/>
            reliably indicates the outcome of the transaction.
            </summary>
        </member>
        <member name="P:Shielded.CommitContinuation.Committed">
            <summary>
            True if this continuation has successfully committed.
            </summary>
        </member>
        <member name="M:Shielded.CommitContinuation.Commit">
            <summary>
            Commit the transaction held in this continuation. Throws if it's already completing/ed.
            </summary>
        </member>
        <member name="M:Shielded.CommitContinuation.TryCommit">
            <summary>
            Try to commit the transaction held in this continuation, returning true if successful.
            It returns true only if this call actually did the full commit.
            </summary>
        </member>
        <member name="M:Shielded.CommitContinuation.Rollback">
            <summary>
            Roll back the transaction held in this continuation. Throws if already completing/ed.
            </summary>
        </member>
        <member name="M:Shielded.CommitContinuation.TryRollback">
            <summary>
            Try to roll back the transaction held in this continuation, returning true if successful.
            Returns true only if this call actually performs the rollback.
            </summary>
        </member>
        <member name="P:Shielded.CommitContinuation.Fields">
            <summary>
            Meta-info on the fields affected by this transaction.
            </summary>
        </member>
        <member name="M:Shielded.CommitContinuation.InContext(System.Action{Shielded.TransactionField[]})">
            <summary>
            Run the action inside the transaction context, with information on the
            transaction's access pattern given in its argument. Access is limited to
            exactly what the main transaction already did. Throws if the continuation
            has completed, dangerous if it is completing.
            </summary>
        </member>
        <member name="M:Shielded.CommitContinuation.InContext(System.Action)">
            <summary>
            Run the action inside the transaction context. Access is limited to
            exactly what the main transaction already did. Throws if the continuation
            has completed, dangerous if it is completing.
            </summary>
        </member>
        <member name="M:Shielded.CommitContinuation.Dispose">
            <summary>
            If not <see cref="P:Shielded.CommitContinuation.Completed"/>, calls <see cref="M:Shielded.CommitContinuation.Rollback"/>.
            </summary>
        </member>
        <member name="T:Shielded.TransactionalStorage`1">
            <summary>
            Transactional storage, internal.
            </summary>
        </member>
        <member name="P:Shielded.TransactionalStorage`1.HasValue">
            <summary>
            Returns <c>true</c> if current transaction has something inside this storage.
            </summary>
        </member>
        <member name="P:Shielded.TransactionalStorage`1.Value">
            <summary>
            Gets or sets the value in the current transaction. Use <see cref="M:Shielded.TransactionalStorage`1.Release"/>
            to release the storage.
            </summary>
        </member>
        <member name="M:Shielded.TransactionalStorage`1.Release">
            <summary>
            Release the storage of this object in the current transaction.
            </summary>
        </member>
        <member name="T:Shielded.ShieldedLocal`1">
            <summary>
            Transactional local storage, lasts only during one transaction run and is
            reset when the transaction restarts or ends. Any value is still available in
            WhenCommitting and SyncSideEffect subscriptions, and in the context of
            a RunToCommit continuation. Throws if used outside of transactions.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedLocal`1.HasValue">
            <summary>
            Returns true if there is a value written in this local in this transaction.
            </summary>
        </member>
        <member name="P:Shielded.ShieldedLocal`1.Value">
            <summary>
            Gets or sets the value contained in the local. If no value was set during
            this transaction, the getter throws.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedLocal`1.op_Implicit(Shielded.ShieldedLocal{`0})~`0">
            <summary>
            Returns the current <see cref="P:Shielded.ShieldedLocal`1.Value"/>.
            </summary>
        </member>
        <member name="M:Shielded.ShieldedLocal`1.Release">
            <summary>
            Releases the storage, if any was used in the current transaction. Does not
            throw if it was not used.
            </summary>
        </member>
    </members>
</doc>
